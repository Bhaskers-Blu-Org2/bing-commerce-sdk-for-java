/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.bing.ecommerce.ingestion.implementation;

import com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.bing.ecommerce.ingestion.models.Index;
import com.microsoft.bing.ecommerce.ingestion.models.IndexResponse;
import com.microsoft.bing.ecommerce.ingestion.models.IndexStatusResponse;
import com.microsoft.bing.ecommerce.ingestion.models.PushDataUpdateResponse;
import com.microsoft.bing.ecommerce.ingestion.models.PushUpdateStatusResponse;
import com.microsoft.bing.ecommerce.ingestion.models.SchemaDetectionResponse;
import com.microsoft.bing.ecommerce.ingestion.models.TransformationConfigResponse;
import com.microsoft.bing.ecommerce.ingestion.models.TransformationTryoutResponse;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the BingECommerceIngestion class.
 */
public class BingECommerceIngestionImpl extends ServiceClient implements BingECommerceIngestion {
    /**
     * The Retrofit service to perform REST calls.
     */
    private BingECommerceIngestionService service;

    /**
     * Initializes an instance of BingECommerceIngestion client.
     */
    public BingECommerceIngestionImpl() {
        this("https://www.bingapis.com/api/v1");
    }

    /**
     * Initializes an instance of BingECommerceIngestion client.
     *
     * @param baseUrl the base URL of the host
     */
    public BingECommerceIngestionImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of BingECommerceIngestion client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public BingECommerceIngestionImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("https://www.bingapis.com/api/v1", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of BingECommerceIngestion client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public BingECommerceIngestionImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of BingECommerceIngestion client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public BingECommerceIngestionImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(BingECommerceIngestionService.class);
    }

    /**
     * The interface defining all the services for BingECommerceIngestion to be
     * used by Retrofit to perform actually REST calls.
     */
    interface BingECommerceIngestionService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion createIndex" })
        @POST("retail/ingestion/{tenantid}/indexes")
        Observable<Response<ResponseBody>> createIndex(@Path("tenantid") String tenantid, @Header("SubscriptionId") String subscriptionId, @Body Index body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion getAllIndexes" })
        @GET("retail/ingestion/{tenantid}/indexes")
        Observable<Response<ResponseBody>> getAllIndexes(@Path("tenantid") String tenantid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion deleteIndex" })
        @HTTP(path = "retail/ingestion/{tenantid}/indexes/{indexid}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteIndex(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion updateIndex" })
        @PUT("retail/ingestion/{tenantid}/indexes/{indexid}")
        Observable<Response<ResponseBody>> updateIndex(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId, @Body Index body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion getIndex" })
        @GET("retail/ingestion/{tenantid}/indexes/{indexid}")
        Observable<Response<ResponseBody>> getIndex(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion getIndexStatus" })
        @GET("retail/ingestion/{tenantid}/indexes/{indexid}/status")
        Observable<Response<ResponseBody>> getIndexStatus(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: text/plain", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion pushDataUpdate" })
        @POST("retail/ingestion/{tenantid}/indexes/{indexid}/pushdata")
        Observable<Response<ResponseBody>> pushDataUpdate(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId, @Query("notransform") Boolean notransform, @Query("updateid") String updateid, @Body String body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion pushDataStatus" })
        @GET("retail/ingestion/{tenantid}/indexes/{indexid}/status/{updateid}")
        Observable<Response<ResponseBody>> pushDataStatus(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Path("updateid") String updateid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion deleteTransformationConfig" })
        @HTTP(path = "retail/ingestion/{tenantid}/indexes/{indexid}/transformationconfig", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteTransformationConfig(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: text/plain", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion createOrUpdateTransformationConfig" })
        @PUT("retail/ingestion/{tenantid}/indexes/{indexid}/transformationconfig")
        Observable<Response<ResponseBody>> createOrUpdateTransformationConfig(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId, @Body String body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion getTransformationConfig" })
        @GET("retail/ingestion/{tenantid}/indexes/{indexid}/transformationconfig")
        Observable<Response<ResponseBody>> getTransformationConfig(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: text/plain", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion uploadTryOutConfig" })
        @POST("retail/ingestion/transformation/tryout")
        Observable<Response<ResponseBody>> uploadTryOutConfig(@Header("SubscriptionId") String subscriptionId, @Body String body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion executeTryOutConfig" })
        @POST("retail/ingestion/transformation/tryout/{tryoutid}")
        Observable<Response<ResponseBody>> executeTryOutConfig(@Path("tryoutid") String tryoutid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.ecommerce.ingestion.BingECommerceIngestion detectSchema" })
        @POST("retail/ingestion/schemadetection")
        Observable<Response<ResponseBody>> detectSchema(@Header("SubscriptionId") String subscriptionId, @Query("format") String format);

    }

    /**
     *
     * @param tenantid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse createIndex(String tenantid) {
        return createIndexWithServiceResponseAsync(tenantid).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> createIndexAsync(String tenantid, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(createIndexWithServiceResponseAsync(tenantid), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> createIndexAsync(String tenantid) {
        return createIndexWithServiceResponseAsync(tenantid).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> createIndexWithServiceResponseAsync(String tenantid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        final String subscriptionId = null;
        final Index body = null;
        return service.createIndex(tenantid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = createIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param tenantid the String value
     * @param subscriptionId the String value
     * @param body the Index value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse createIndex(String tenantid, String subscriptionId, Index body) {
        return createIndexWithServiceResponseAsync(tenantid, subscriptionId, body).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param subscriptionId the String value
     * @param body the Index value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> createIndexAsync(String tenantid, String subscriptionId, Index body, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(createIndexWithServiceResponseAsync(tenantid, subscriptionId, body), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param subscriptionId the String value
     * @param body the Index value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> createIndexAsync(String tenantid, String subscriptionId, Index body) {
        return createIndexWithServiceResponseAsync(tenantid, subscriptionId, body).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param subscriptionId the String value
     * @param body the Index value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> createIndexWithServiceResponseAsync(String tenantid, String subscriptionId, Index body) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        Validator.validate(body);
        return service.createIndex(tenantid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = createIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexResponse> createIndexDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IndexResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IndexResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param tenantid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse getAllIndexes(String tenantid) {
        return getAllIndexesWithServiceResponseAsync(tenantid).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> getAllIndexesAsync(String tenantid, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getAllIndexesWithServiceResponseAsync(tenantid), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> getAllIndexesAsync(String tenantid) {
        return getAllIndexesWithServiceResponseAsync(tenantid).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> getAllIndexesWithServiceResponseAsync(String tenantid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.getAllIndexes(tenantid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = getAllIndexesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param tenantid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse getAllIndexes(String tenantid, String subscriptionId) {
        return getAllIndexesWithServiceResponseAsync(tenantid, subscriptionId).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param subscriptionId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> getAllIndexesAsync(String tenantid, String subscriptionId, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getAllIndexesWithServiceResponseAsync(tenantid, subscriptionId), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> getAllIndexesAsync(String tenantid, String subscriptionId) {
        return getAllIndexesWithServiceResponseAsync(tenantid, subscriptionId).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> getAllIndexesWithServiceResponseAsync(String tenantid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        return service.getAllIndexes(tenantid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = getAllIndexesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexResponse> getAllIndexesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IndexResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IndexResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse deleteIndex(String tenantid, String indexid) {
        return deleteIndexWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> deleteIndexAsync(String tenantid, String indexid, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(deleteIndexWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> deleteIndexAsync(String tenantid, String indexid) {
        return deleteIndexWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> deleteIndexWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.deleteIndex(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = deleteIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse deleteIndex(String tenantid, String indexid, String subscriptionId) {
        return deleteIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> deleteIndexAsync(String tenantid, String indexid, String subscriptionId, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(deleteIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> deleteIndexAsync(String tenantid, String indexid, String subscriptionId) {
        return deleteIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> deleteIndexWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.deleteIndex(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = deleteIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexResponse> deleteIndexDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IndexResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IndexResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse updateIndex(String tenantid, String indexid) {
        return updateIndexWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> updateIndexAsync(String tenantid, String indexid, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(updateIndexWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> updateIndexAsync(String tenantid, String indexid) {
        return updateIndexWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> updateIndexWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        final Index body = null;
        return service.updateIndex(tenantid, indexid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = updateIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param body the Index value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse updateIndex(String tenantid, String indexid, String subscriptionId, Index body) {
        return updateIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId, body).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param body the Index value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> updateIndexAsync(String tenantid, String indexid, String subscriptionId, Index body, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(updateIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId, body), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param body the Index value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> updateIndexAsync(String tenantid, String indexid, String subscriptionId, Index body) {
        return updateIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId, body).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param body the Index value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> updateIndexWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId, Index body) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateIndex(tenantid, indexid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = updateIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexResponse> updateIndexDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IndexResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IndexResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse getIndex(String tenantid, String indexid) {
        return getIndexWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> getIndexAsync(String tenantid, String indexid, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getIndexWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> getIndexAsync(String tenantid, String indexid) {
        return getIndexWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> getIndexWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.getIndex(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = getIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse getIndex(String tenantid, String indexid, String subscriptionId) {
        return getIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> getIndexAsync(String tenantid, String indexid, String subscriptionId, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> getIndexAsync(String tenantid, String indexid, String subscriptionId) {
        return getIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> getIndexWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.getIndex(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = getIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexResponse> getIndexDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IndexResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IndexResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexStatusResponse object if successful.
     */
    public IndexStatusResponse getIndexStatus(String tenantid, String indexid) {
        return getIndexStatusWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexStatusResponse> getIndexStatusAsync(String tenantid, String indexid, final ServiceCallback<IndexStatusResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getIndexStatusWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexStatusResponse object
     */
    public Observable<IndexStatusResponse> getIndexStatusAsync(String tenantid, String indexid) {
        return getIndexStatusWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<IndexStatusResponse>, IndexStatusResponse>() {
            @Override
            public IndexStatusResponse call(ServiceResponse<IndexStatusResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexStatusResponse object
     */
    public Observable<ServiceResponse<IndexStatusResponse>> getIndexStatusWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.getIndexStatus(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexStatusResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexStatusResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexStatusResponse> clientResponse = getIndexStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexStatusResponse object if successful.
     */
    public IndexStatusResponse getIndexStatus(String tenantid, String indexid, String subscriptionId) {
        return getIndexStatusWithServiceResponseAsync(tenantid, indexid, subscriptionId).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexStatusResponse> getIndexStatusAsync(String tenantid, String indexid, String subscriptionId, final ServiceCallback<IndexStatusResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getIndexStatusWithServiceResponseAsync(tenantid, indexid, subscriptionId), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexStatusResponse object
     */
    public Observable<IndexStatusResponse> getIndexStatusAsync(String tenantid, String indexid, String subscriptionId) {
        return getIndexStatusWithServiceResponseAsync(tenantid, indexid, subscriptionId).map(new Func1<ServiceResponse<IndexStatusResponse>, IndexStatusResponse>() {
            @Override
            public IndexStatusResponse call(ServiceResponse<IndexStatusResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexStatusResponse object
     */
    public Observable<ServiceResponse<IndexStatusResponse>> getIndexStatusWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.getIndexStatus(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexStatusResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexStatusResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexStatusResponse> clientResponse = getIndexStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexStatusResponse> getIndexStatusDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IndexStatusResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IndexStatusResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushDataUpdateResponse object if successful.
     */
    public PushDataUpdateResponse pushDataUpdate(String body, String tenantid, String indexid) {
        return pushDataUpdateWithServiceResponseAsync(body, tenantid, indexid).toBlocking().single().body();
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushDataUpdateResponse> pushDataUpdateAsync(String body, String tenantid, String indexid, final ServiceCallback<PushDataUpdateResponse> serviceCallback) {
        return ServiceFuture.fromResponse(pushDataUpdateWithServiceResponseAsync(body, tenantid, indexid), serviceCallback);
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushDataUpdateResponse object
     */
    public Observable<PushDataUpdateResponse> pushDataUpdateAsync(String body, String tenantid, String indexid) {
        return pushDataUpdateWithServiceResponseAsync(body, tenantid, indexid).map(new Func1<ServiceResponse<PushDataUpdateResponse>, PushDataUpdateResponse>() {
            @Override
            public PushDataUpdateResponse call(ServiceResponse<PushDataUpdateResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushDataUpdateResponse object
     */
    public Observable<ServiceResponse<PushDataUpdateResponse>> pushDataUpdateWithServiceResponseAsync(String body, String tenantid, String indexid) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        final Boolean notransform = null;
        final String updateid = null;
        return service.pushDataUpdate(tenantid, indexid, subscriptionId, notransform, updateid, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushDataUpdateResponse>>>() {
                @Override
                public Observable<ServiceResponse<PushDataUpdateResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushDataUpdateResponse> clientResponse = pushDataUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param notransform the Boolean value
     * @param updateid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushDataUpdateResponse object if successful.
     */
    public PushDataUpdateResponse pushDataUpdate(String body, String tenantid, String indexid, String subscriptionId, Boolean notransform, String updateid) {
        return pushDataUpdateWithServiceResponseAsync(body, tenantid, indexid, subscriptionId, notransform, updateid).toBlocking().single().body();
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param notransform the Boolean value
     * @param updateid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushDataUpdateResponse> pushDataUpdateAsync(String body, String tenantid, String indexid, String subscriptionId, Boolean notransform, String updateid, final ServiceCallback<PushDataUpdateResponse> serviceCallback) {
        return ServiceFuture.fromResponse(pushDataUpdateWithServiceResponseAsync(body, tenantid, indexid, subscriptionId, notransform, updateid), serviceCallback);
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param notransform the Boolean value
     * @param updateid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushDataUpdateResponse object
     */
    public Observable<PushDataUpdateResponse> pushDataUpdateAsync(String body, String tenantid, String indexid, String subscriptionId, Boolean notransform, String updateid) {
        return pushDataUpdateWithServiceResponseAsync(body, tenantid, indexid, subscriptionId, notransform, updateid).map(new Func1<ServiceResponse<PushDataUpdateResponse>, PushDataUpdateResponse>() {
            @Override
            public PushDataUpdateResponse call(ServiceResponse<PushDataUpdateResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param notransform the Boolean value
     * @param updateid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushDataUpdateResponse object
     */
    public Observable<ServiceResponse<PushDataUpdateResponse>> pushDataUpdateWithServiceResponseAsync(String body, String tenantid, String indexid, String subscriptionId, Boolean notransform, String updateid) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.pushDataUpdate(tenantid, indexid, subscriptionId, notransform, updateid, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushDataUpdateResponse>>>() {
                @Override
                public Observable<ServiceResponse<PushDataUpdateResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushDataUpdateResponse> clientResponse = pushDataUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushDataUpdateResponse> pushDataUpdateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PushDataUpdateResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PushDataUpdateResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param updateid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushUpdateStatusResponse object if successful.
     */
    public PushUpdateStatusResponse pushDataStatus(String tenantid, String indexid, String updateid) {
        return pushDataStatusWithServiceResponseAsync(tenantid, indexid, updateid).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param updateid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushUpdateStatusResponse> pushDataStatusAsync(String tenantid, String indexid, String updateid, final ServiceCallback<PushUpdateStatusResponse> serviceCallback) {
        return ServiceFuture.fromResponse(pushDataStatusWithServiceResponseAsync(tenantid, indexid, updateid), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param updateid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushUpdateStatusResponse object
     */
    public Observable<PushUpdateStatusResponse> pushDataStatusAsync(String tenantid, String indexid, String updateid) {
        return pushDataStatusWithServiceResponseAsync(tenantid, indexid, updateid).map(new Func1<ServiceResponse<PushUpdateStatusResponse>, PushUpdateStatusResponse>() {
            @Override
            public PushUpdateStatusResponse call(ServiceResponse<PushUpdateStatusResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param updateid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushUpdateStatusResponse object
     */
    public Observable<ServiceResponse<PushUpdateStatusResponse>> pushDataStatusWithServiceResponseAsync(String tenantid, String indexid, String updateid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        if (updateid == null) {
            throw new IllegalArgumentException("Parameter updateid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.pushDataStatus(tenantid, indexid, updateid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushUpdateStatusResponse>>>() {
                @Override
                public Observable<ServiceResponse<PushUpdateStatusResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushUpdateStatusResponse> clientResponse = pushDataStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param updateid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushUpdateStatusResponse object if successful.
     */
    public PushUpdateStatusResponse pushDataStatus(String tenantid, String indexid, String updateid, String subscriptionId) {
        return pushDataStatusWithServiceResponseAsync(tenantid, indexid, updateid, subscriptionId).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param updateid the String value
     * @param subscriptionId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushUpdateStatusResponse> pushDataStatusAsync(String tenantid, String indexid, String updateid, String subscriptionId, final ServiceCallback<PushUpdateStatusResponse> serviceCallback) {
        return ServiceFuture.fromResponse(pushDataStatusWithServiceResponseAsync(tenantid, indexid, updateid, subscriptionId), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param updateid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushUpdateStatusResponse object
     */
    public Observable<PushUpdateStatusResponse> pushDataStatusAsync(String tenantid, String indexid, String updateid, String subscriptionId) {
        return pushDataStatusWithServiceResponseAsync(tenantid, indexid, updateid, subscriptionId).map(new Func1<ServiceResponse<PushUpdateStatusResponse>, PushUpdateStatusResponse>() {
            @Override
            public PushUpdateStatusResponse call(ServiceResponse<PushUpdateStatusResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param updateid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushUpdateStatusResponse object
     */
    public Observable<ServiceResponse<PushUpdateStatusResponse>> pushDataStatusWithServiceResponseAsync(String tenantid, String indexid, String updateid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        if (updateid == null) {
            throw new IllegalArgumentException("Parameter updateid is required and cannot be null.");
        }
        return service.pushDataStatus(tenantid, indexid, updateid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushUpdateStatusResponse>>>() {
                @Override
                public Observable<ServiceResponse<PushUpdateStatusResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushUpdateStatusResponse> clientResponse = pushDataStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushUpdateStatusResponse> pushDataStatusDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PushUpdateStatusResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PushUpdateStatusResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse deleteTransformationConfig(String tenantid, String indexid) {
        return deleteTransformationConfigWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> deleteTransformationConfigAsync(String tenantid, String indexid, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(deleteTransformationConfigWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> deleteTransformationConfigAsync(String tenantid, String indexid) {
        return deleteTransformationConfigWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> deleteTransformationConfigWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.deleteTransformationConfig(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = deleteTransformationConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse deleteTransformationConfig(String tenantid, String indexid, String subscriptionId) {
        return deleteTransformationConfigWithServiceResponseAsync(tenantid, indexid, subscriptionId).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> deleteTransformationConfigAsync(String tenantid, String indexid, String subscriptionId, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(deleteTransformationConfigWithServiceResponseAsync(tenantid, indexid, subscriptionId), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> deleteTransformationConfigAsync(String tenantid, String indexid, String subscriptionId) {
        return deleteTransformationConfigWithServiceResponseAsync(tenantid, indexid, subscriptionId).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> deleteTransformationConfigWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.deleteTransformationConfig(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = deleteTransformationConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransformationConfigResponse> deleteTransformationConfigDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TransformationConfigResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TransformationConfigResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse createOrUpdateTransformationConfig(String body, String tenantid, String indexid) {
        return createOrUpdateTransformationConfigWithServiceResponseAsync(body, tenantid, indexid).toBlocking().single().body();
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> createOrUpdateTransformationConfigAsync(String body, String tenantid, String indexid, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateTransformationConfigWithServiceResponseAsync(body, tenantid, indexid), serviceCallback);
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> createOrUpdateTransformationConfigAsync(String body, String tenantid, String indexid) {
        return createOrUpdateTransformationConfigWithServiceResponseAsync(body, tenantid, indexid).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> createOrUpdateTransformationConfigWithServiceResponseAsync(String body, String tenantid, String indexid) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.createOrUpdateTransformationConfig(tenantid, indexid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = createOrUpdateTransformationConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse createOrUpdateTransformationConfig(String body, String tenantid, String indexid, String subscriptionId) {
        return createOrUpdateTransformationConfigWithServiceResponseAsync(body, tenantid, indexid, subscriptionId).toBlocking().single().body();
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> createOrUpdateTransformationConfigAsync(String body, String tenantid, String indexid, String subscriptionId, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateTransformationConfigWithServiceResponseAsync(body, tenantid, indexid, subscriptionId), serviceCallback);
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> createOrUpdateTransformationConfigAsync(String body, String tenantid, String indexid, String subscriptionId) {
        return createOrUpdateTransformationConfigWithServiceResponseAsync(body, tenantid, indexid, subscriptionId).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param body the String value
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> createOrUpdateTransformationConfigWithServiceResponseAsync(String body, String tenantid, String indexid, String subscriptionId) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.createOrUpdateTransformationConfig(tenantid, indexid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = createOrUpdateTransformationConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransformationConfigResponse> createOrUpdateTransformationConfigDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TransformationConfigResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TransformationConfigResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse getTransformationConfig(String tenantid, String indexid) {
        return getTransformationConfigWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> getTransformationConfigAsync(String tenantid, String indexid, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getTransformationConfigWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> getTransformationConfigAsync(String tenantid, String indexid) {
        return getTransformationConfigWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> getTransformationConfigWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.getTransformationConfig(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = getTransformationConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse getTransformationConfig(String tenantid, String indexid, String subscriptionId) {
        return getTransformationConfigWithServiceResponseAsync(tenantid, indexid, subscriptionId).toBlocking().single().body();
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> getTransformationConfigAsync(String tenantid, String indexid, String subscriptionId, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getTransformationConfigWithServiceResponseAsync(tenantid, indexid, subscriptionId), serviceCallback);
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> getTransformationConfigAsync(String tenantid, String indexid, String subscriptionId) {
        return getTransformationConfigWithServiceResponseAsync(tenantid, indexid, subscriptionId).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tenantid the String value
     * @param indexid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> getTransformationConfigWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.getTransformationConfig(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = getTransformationConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransformationConfigResponse> getTransformationConfigDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TransformationConfigResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TransformationConfigResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param body the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse uploadTryOutConfig(String body) {
        return uploadTryOutConfigWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     *
     * @param body the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> uploadTryOutConfigAsync(String body, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(uploadTryOutConfigWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     *
     * @param body the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> uploadTryOutConfigAsync(String body) {
        return uploadTryOutConfigWithServiceResponseAsync(body).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param body the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> uploadTryOutConfigWithServiceResponseAsync(String body) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.uploadTryOutConfig(subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = uploadTryOutConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param body the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse uploadTryOutConfig(String body, String subscriptionId) {
        return uploadTryOutConfigWithServiceResponseAsync(body, subscriptionId).toBlocking().single().body();
    }

    /**
     *
     * @param body the String value
     * @param subscriptionId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> uploadTryOutConfigAsync(String body, String subscriptionId, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(uploadTryOutConfigWithServiceResponseAsync(body, subscriptionId), serviceCallback);
    }

    /**
     *
     * @param body the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> uploadTryOutConfigAsync(String body, String subscriptionId) {
        return uploadTryOutConfigWithServiceResponseAsync(body, subscriptionId).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param body the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> uploadTryOutConfigWithServiceResponseAsync(String body, String subscriptionId) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        return service.uploadTryOutConfig(subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = uploadTryOutConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransformationConfigResponse> uploadTryOutConfigDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TransformationConfigResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TransformationConfigResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param tryoutid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationTryoutResponse object if successful.
     */
    public TransformationTryoutResponse executeTryOutConfig(String tryoutid) {
        return executeTryOutConfigWithServiceResponseAsync(tryoutid).toBlocking().single().body();
    }

    /**
     *
     * @param tryoutid the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationTryoutResponse> executeTryOutConfigAsync(String tryoutid, final ServiceCallback<TransformationTryoutResponse> serviceCallback) {
        return ServiceFuture.fromResponse(executeTryOutConfigWithServiceResponseAsync(tryoutid), serviceCallback);
    }

    /**
     *
     * @param tryoutid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationTryoutResponse object
     */
    public Observable<TransformationTryoutResponse> executeTryOutConfigAsync(String tryoutid) {
        return executeTryOutConfigWithServiceResponseAsync(tryoutid).map(new Func1<ServiceResponse<TransformationTryoutResponse>, TransformationTryoutResponse>() {
            @Override
            public TransformationTryoutResponse call(ServiceResponse<TransformationTryoutResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tryoutid the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationTryoutResponse object
     */
    public Observable<ServiceResponse<TransformationTryoutResponse>> executeTryOutConfigWithServiceResponseAsync(String tryoutid) {
        if (tryoutid == null) {
            throw new IllegalArgumentException("Parameter tryoutid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.executeTryOutConfig(tryoutid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationTryoutResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationTryoutResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationTryoutResponse> clientResponse = executeTryOutConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param tryoutid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationTryoutResponse object if successful.
     */
    public TransformationTryoutResponse executeTryOutConfig(String tryoutid, String subscriptionId) {
        return executeTryOutConfigWithServiceResponseAsync(tryoutid, subscriptionId).toBlocking().single().body();
    }

    /**
     *
     * @param tryoutid the String value
     * @param subscriptionId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationTryoutResponse> executeTryOutConfigAsync(String tryoutid, String subscriptionId, final ServiceCallback<TransformationTryoutResponse> serviceCallback) {
        return ServiceFuture.fromResponse(executeTryOutConfigWithServiceResponseAsync(tryoutid, subscriptionId), serviceCallback);
    }

    /**
     *
     * @param tryoutid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationTryoutResponse object
     */
    public Observable<TransformationTryoutResponse> executeTryOutConfigAsync(String tryoutid, String subscriptionId) {
        return executeTryOutConfigWithServiceResponseAsync(tryoutid, subscriptionId).map(new Func1<ServiceResponse<TransformationTryoutResponse>, TransformationTryoutResponse>() {
            @Override
            public TransformationTryoutResponse call(ServiceResponse<TransformationTryoutResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param tryoutid the String value
     * @param subscriptionId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationTryoutResponse object
     */
    public Observable<ServiceResponse<TransformationTryoutResponse>> executeTryOutConfigWithServiceResponseAsync(String tryoutid, String subscriptionId) {
        if (tryoutid == null) {
            throw new IllegalArgumentException("Parameter tryoutid is required and cannot be null.");
        }
        return service.executeTryOutConfig(tryoutid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationTryoutResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationTryoutResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationTryoutResponse> clientResponse = executeTryOutConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransformationTryoutResponse> executeTryOutConfigDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TransformationTryoutResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TransformationTryoutResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SchemaDetectionResponse object if successful.
     */
    public SchemaDetectionResponse detectSchema() {
        return detectSchemaWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SchemaDetectionResponse> detectSchemaAsync(final ServiceCallback<SchemaDetectionResponse> serviceCallback) {
        return ServiceFuture.fromResponse(detectSchemaWithServiceResponseAsync(), serviceCallback);
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SchemaDetectionResponse object
     */
    public Observable<SchemaDetectionResponse> detectSchemaAsync() {
        return detectSchemaWithServiceResponseAsync().map(new Func1<ServiceResponse<SchemaDetectionResponse>, SchemaDetectionResponse>() {
            @Override
            public SchemaDetectionResponse call(ServiceResponse<SchemaDetectionResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SchemaDetectionResponse object
     */
    public Observable<ServiceResponse<SchemaDetectionResponse>> detectSchemaWithServiceResponseAsync() {
        final String subscriptionId = null;
        final String format = null;
        return service.detectSchema(subscriptionId, format)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SchemaDetectionResponse>>>() {
                @Override
                public Observable<ServiceResponse<SchemaDetectionResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SchemaDetectionResponse> clientResponse = detectSchemaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param subscriptionId the String value
     * @param format Possible values include: 'Unknown', 'LDJson', 'CSV', 'TSV', 'JsonArray'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SchemaDetectionResponse object if successful.
     */
    public SchemaDetectionResponse detectSchema(String subscriptionId, String format) {
        return detectSchemaWithServiceResponseAsync(subscriptionId, format).toBlocking().single().body();
    }

    /**
     *
     * @param subscriptionId the String value
     * @param format Possible values include: 'Unknown', 'LDJson', 'CSV', 'TSV', 'JsonArray'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SchemaDetectionResponse> detectSchemaAsync(String subscriptionId, String format, final ServiceCallback<SchemaDetectionResponse> serviceCallback) {
        return ServiceFuture.fromResponse(detectSchemaWithServiceResponseAsync(subscriptionId, format), serviceCallback);
    }

    /**
     *
     * @param subscriptionId the String value
     * @param format Possible values include: 'Unknown', 'LDJson', 'CSV', 'TSV', 'JsonArray'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SchemaDetectionResponse object
     */
    public Observable<SchemaDetectionResponse> detectSchemaAsync(String subscriptionId, String format) {
        return detectSchemaWithServiceResponseAsync(subscriptionId, format).map(new Func1<ServiceResponse<SchemaDetectionResponse>, SchemaDetectionResponse>() {
            @Override
            public SchemaDetectionResponse call(ServiceResponse<SchemaDetectionResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param subscriptionId the String value
     * @param format Possible values include: 'Unknown', 'LDJson', 'CSV', 'TSV', 'JsonArray'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SchemaDetectionResponse object
     */
    public Observable<ServiceResponse<SchemaDetectionResponse>> detectSchemaWithServiceResponseAsync(String subscriptionId, String format) {
        return service.detectSchema(subscriptionId, format)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SchemaDetectionResponse>>>() {
                @Override
                public Observable<ServiceResponse<SchemaDetectionResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SchemaDetectionResponse> clientResponse = detectSchemaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SchemaDetectionResponse> detectSchemaDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<SchemaDetectionResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SchemaDetectionResponse>() { }.getType())
                .build(response);
    }

}
